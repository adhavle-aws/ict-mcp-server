AWSTemplateFormatVersion: '2010-09-09'
Description: WebSocket API for CloudFormation Builder (No DynamoDB - Demo)

Parameters:
  AgentArn:
    Type: String
    Description: AgentCore Runtime ARN
    Default: arn:aws:bedrock-agentcore:us-east-1:905767016260:runtime/mcp_server-VpWbdyCLTH

Resources:
  # WebSocket API
  WebSocketApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: cfn-builder-websocket
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: '$request.body.action'

  # Lambda Execution Role
  WebSocketLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: WebSocketPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - execute-api:ManageConnections
                Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:*
                Resource: 'arn:aws:bedrock-agentcore:*:*:*'
              - Effect: Allow
                Action:
                  - cloudformation:DescribeStacks
                Resource: '*'

  # Lambda Function
  WebSocketLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: cfn-builder-websocket
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt WebSocketLambdaRole.Arn
      Timeout: 600
      MemorySize: 512
      Environment:
        Variables:
          AGENT_ARN: !Ref AgentArn
          REGION: !Ref AWS::Region
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          from botocore.auth import SigV4Auth
          from botocore.awsrequest import AWSRequest
          import urllib.request
          import threading
          
          AGENT_ARN = os.environ['AGENT_ARN']
          REGION = os.environ.get('REGION', 'us-east-1')
          
          # API Gateway Management API client
          apigw = None
          
          def get_apigw_client(event):
              global apigw
              if apigw is None:
                  domain = event['requestContext']['domainName']
                  stage = event['requestContext']['stage']
                  endpoint = f"https://{domain}/{stage}"
                  apigw = boto3.client('apigatewaymanagementapi', endpoint_url=endpoint)
              return apigw
          
          def send_message(connection_id, message, event):
              try:
                  client = get_apigw_client(event)
                  client.post_to_connection(
                      ConnectionId=connection_id,
                      Data=json.dumps(message)
                  )
                  return True
              except Exception as e:
                  print(f"Error sending message: {e}")
                  return False
          
          def call_mcp_tool_async(connection_id, request_id, tool_name, arguments, event):
              """Call MCP tool asynchronously and send result via WebSocket"""
              try:
                  # Send progress update
                  send_message(connection_id, {
                      'type': 'progress',
                      'requestId': request_id,
                      'progress': 50,
                      'message': f'Processing {tool_name}...'
                  }, event)
                  
                  session = boto3.Session()
                  credentials = session.get_credentials()
                  
                  encoded_arn = AGENT_ARN.replace(':', '%3A').replace('/', '%2F')
                  mcp_url = f"https://bedrock-agentcore.{REGION}.amazonaws.com/runtimes/{encoded_arn}/invocations?qualifier=DEFAULT"
                  
                  request_body = json.dumps({
                      'jsonrpc': '2.0',
                      'id': 1,
                      'method': 'tools/call',
                      'params': {
                          'name': tool_name,
                          'arguments': arguments
                      }
                  })
                  
                  aws_request = AWSRequest(
                      method='POST',
                      url=mcp_url,
                      data=request_body,
                      headers={
                          'Content-Type': 'application/json',
                          'Accept': 'application/json, text/event-stream',
                      }
                  )
                  
                  SigV4Auth(credentials, 'bedrock-agentcore', REGION).add_auth(aws_request)
                  
                  req = urllib.request.Request(
                      mcp_url,
                      data=request_body.encode('utf-8'),
                      headers=dict(aws_request.headers)
                  )
                  
                  with urllib.request.urlopen(req, timeout=300) as response:
                      response_data = response.read().decode('utf-8')
                      
                      # Parse SSE format
                      result = None
                      if response_data.startswith('event:'):
                          lines = response_data.split('\n')
                          for line in lines:
                              if line.startswith('data: '):
                                  json_data = line[6:]
                                  result = json.loads(json_data)
                                  break
                      else:
                          if response_data.strip():
                              result = json.loads(response_data)
                      
                      if result and result.get('result', {}).get('content'):
                          content_text = result['result']['content'][0]['text']
                          data = json.loads(content_text)
                          
                          # Send final response
                          send_message(connection_id, {
                              'type': 'response',
                              'requestId': request_id,
                              'tool': tool_name,
                              'data': data,
                              'status': 'completed'
                          }, event)
                      else:
                          send_message(connection_id, {
                              'type': 'error',
                              'requestId': request_id,
                              'error': 'No result from MCP server'
                          }, event)
              
              except Exception as e:
                  print(f"Error in async call: {e}")
                  import traceback
                  traceback.print_exc()
                  send_message(connection_id, {
                      'type': 'error',
                      'requestId': request_id,
                      'error': str(e)
                  }, event)
          
          def lambda_handler(event, context):
              route_key = event.get('requestContext', {}).get('routeKey')
              connection_id = event.get('requestContext', {}).get('connectionId')
              
              print(f"Route: {route_key}, Connection: {connection_id}")
              
              try:
                  if route_key == '$connect':
                      print(f"Client connected: {connection_id}")
                      return {'statusCode': 200}
                  
                  elif route_key == '$disconnect':
                      print(f"Client disconnected: {connection_id}")
                      return {'statusCode': 200}
                  
                  elif route_key == '$default':
                      body = json.loads(event.get('body', '{}'))
                      request_id = body.get('id')
                      tool = body.get('tool')
                      arguments = body.get('arguments', {})
                      
                      print(f"Tool: {tool}, Request: {request_id}")
                      
                      # Send acknowledgment immediately
                      send_message(connection_id, {
                          'type': 'acknowledged',
                          'requestId': request_id,
                          'tool': tool
                      }, event)
                      
                      # Start async processing in background thread
                      # This allows Lambda to return within 30 seconds
                      thread = threading.Thread(
                          target=call_mcp_tool_async,
                          args=(connection_id, request_id, tool, arguments, event)
                      )
                      thread.start()
                      
                      # Return immediately (within 30 seconds)
                      return {'statusCode': 200}
                  
                  else:
                      return {'statusCode': 400}
              
              except Exception as e:
                  print(f"Error: {e}")
                  import traceback
                  traceback.print_exc()
                  
                  if route_key == '$default':
                      try:
                          send_message(connection_id, {
                              'type': 'error',
                              'requestId': body.get('id'),
                              'error': str(e)
                          }, event)
                      except:
                          pass
                  
                  return {'statusCode': 500}
                              'type': 'response',
                              'requestId': request_id,
                              'tool': tool,
                              'data': data,
                              'status': 'completed'
                          }, event)
                      else:
                          send_message(connection_id, {
                              'type': 'error',
                              'requestId': request_id,
                              'error': 'No result from MCP server'
                          }, event)
                      
                      return {'statusCode': 200}
                  
                  else:
                      return {'statusCode': 400}
              
              except Exception as e:
                  print(f"Error: {e}")
                  import traceback
                  traceback.print_exc()
                  
                  if route_key == '$default':
                      try:
                          send_message(connection_id, {
                              'type': 'error',
                              'requestId': body.get('id'),
                              'error': str(e)
                          }, event)
                      except:
                          pass
                  
                  return {'statusCode': 500}

  # Connect Route
  ConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $connect
      Target: !Sub 'integrations/${ConnectIntegration}'

  ConnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${WebSocketLambda}'

  # Default Route
  DefaultRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $default
      Target: !Sub 'integrations/${DefaultIntegration}'

  DefaultIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${WebSocketLambda}'

  # Disconnect Route
  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $disconnect
      Target: !Sub 'integrations/${DisconnectIntegration}'

  DisconnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub 'arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${WebSocketLambda}'

  # Stage
  WebSocketStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref WebSocketApi
      StageName: prod
      AutoDeploy: true

  # Lambda Permissions
  ConnectPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref WebSocketLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*'

Outputs:
  WebSocketUrl:
    Description: WebSocket API endpoint
    Value: !Sub 'wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/prod'
    Export:
      Name: CfnBuilderWebSocketUrl
